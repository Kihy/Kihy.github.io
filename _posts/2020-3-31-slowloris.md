---
layout: post
title:  "Slowloris"
author: "Ke He"
description: "Trying slowloris DoS attack "
---

### The slowloris attack

In normal HTTP traffic, a connection occurs when the browser sends a get request and the server responds with a file, and the connection is then finished. To finish a HTTP request, the browser sends two cartridge return symbols or a timeout is reached. The slowloris attack exploits this by purposely sending a small amount of data to the server(~15 seconds) to keep the connection alive, and by having a lot of these HTTP connections it is able to exhaust the connection pool of the server. The server thinks the attacker just have a really slow internet.

There are two significant advantages of using the slowloris attack for experiments:
1\. Unlike other DoS attacks that rapidly sends requests, slowloris sends very few packets, meaning we would not need to process large amounts of data.
2\. The method of attack is very simple and the python implementation is only ~60 lines, which we can easily manipulate.

### Slowloris in CIC-IDS

Just like other attacks in the dataset, most flows only have 1 forward and backward packet. For slowloris I would imagine it is hard to achieve since the connection has to be kept alive for a long time. So what we are going to do is to gather our own traffic data.

### Custom data generation

To get things started quickly I have only generated a small amount of traffic. Normal traffic was generated by me visiting the dummy website in the network and visiting youtube, reddit and google. The adversarial traffic was me running slowloris.py file to attack the dummy website. The website was checked to make sure the attack was working. The length the activities was not very long, so in the end we only generated:

-   normal       934
-   slowloris    300

### adversarial generation

while generating the adversarial samples, it occurred to me that for DoS attacks in general, it is an instance of the attack(i.e. a sequence of flows) repeated several times. Thus to create adversarial samples we have to look at a number of flows, perturb them, and look at the statistics of the perturbations.

A unconstrained adversarial perturbation was ran on the data, and the results show we have to reduce forward PSH flags and increase forward subflow packets for approximately half of the packets and only increase FIN flag count for the others.
